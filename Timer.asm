
;.include "2313def.inc"
.include "tn2313def.inc"

;Target Device : AT90S2313 / tiny2313

;Fusebit Settings.
;CKDIV8 = off
;CKSEL = External Crystal 3-8MHz
;BODLEVEL = 1.8V
;
;other fuses are default.

;7segment data
.equ SEG0=0b00000010
.equ SEG1=0b10011110
.equ SEG2=0b00100100
.equ SEG3=0b00001100
.equ SEG4=0b10011000
.equ SEG5=0b01001000
;.equ SEG6=0b01000000
.equ SEG6=0b11000000	;Yet Another 6
;.equ SEG7=0b00011010
.equ SEG7=0b00011110	;Yet Another 7
.equ SEG8=0b00000000
;.equ SEG9=0b00001000
.equ SEG9=0b00011000	;Yet Another 9
.equ SEGBL=0b11111110	;Blank

.include "registers.inc"

;.equ KEYIN=0xFF	;Key input sampling
.equ KEYINWAIT_H=0xC0	;Key input sampling
.equ KEYINWAIT_L=0xFF
.equ KEYMASK=0b01001100
.equ SEGON=0xFF	;7SEG ON WAIT TIME
.equ SEGONH=0x1C	;7SEG ON WAIT TIME
.equ SEGONL=0xFF	;7SEG ON WAIT TIME
.equ SEGOFF=1	;7SEG OFF WAIT TIME

.org 0x00
		;Interrupt Vectors (90S2313/tiny2313)
		RJMP RESET
		RJMP EXT_INT0
		RJMP EXT_INT1
		RJMP TIM_CAPT1
		RJMP TIM_COMP1
		RJMP TIM_OVF1
		RJMP TIM_OVF0
		RJMP UART_RXC
		RJMP UART_DRE
		RJMP UART_TXC
		RJMP ANA_COMP
		;Interrupt Vectors (tiny2313)
		RJMP PCINT
		RJMP OC1B
		RJMP OC0A
		RJMP OC0B
		RJMP USI_START
		RJMP USI_OVF
		RJMP ERDY
		RJMP WDT

;Register initialize
RESET:
	;----- peripheral initialize -----
		;Set stack pointer
		LDI GX,RAMEND
		OUT SPL,GX

		;PortB/D
		SER GX
		OUT DDRB,GX		;Set DDRB All output
		LDI GX,0b00110011
		OUT DDRD,GX		;Set PortD direction
		LDI GX,(1<<PORTD6)+(1<<PORTD3)+(1<<PORTD2)
		OUT PORTD,GX	;Set PORTD2,3,6 Pullup

		;Timer1
		LDI GX,0x01
		OUT OCR1AH,GX
		LDI GX,0x12
		OUT OCR1AL,GX	;Comp Reg Set 31250(0x7A12)
		;31250 = (4MHz / 64 / 2) = 500ms

		LDI GX,(1<<OCIE1A)	;Comp INT Enable
		OUT TIMSK,GX
	;----- peripheral initialize -----

		;Detect reset type
		IN GX,MCUSR
		SBRS GX,PORF
		RJMP STAGE0	;IF reset by reset button, then beep

		;PowerON beep
		LDI XH,8
		LDI XL,255
		LDI ARG1,255
		RCALL BEEP
STAGE0:
		;Clear PowerON-reset flag
		CLR GX
		OUT MCUSR,GX

		SEI		;INT ENABLE
		RCALL POWERDOWN

		;WAIT after resume
		LDI ZH,0xFF
		LDI ZL,0xFF
		RCALL WAIT16

		;Set 10:00 (10minute)
		CLR SEC_L
		CLR SEC_H
		CLR MIN_L
		LDI MIN_H,0x01

STAGE1:		;Countdown time setting stage
		RCALL SEG
		RCALL KEYINPUT

		;IF Timer1 started goto Stage 2
		IN GX,TCCR1B
		CPI GX,(1<<WGM12)+(1<<CS11)+(1<<CS10)
		BREQ STAGE2
		RJMP STAGE1
STAGE2:				;Countdown Stage
		;Update 7Segments + LEDs
		RCALL SEG
		RCALL LED

		;IF Timer1 stopped goto Stage 3
		IN GX,TCCR1B
		CPI GX,0b00000000
		BREQ STAGE3
		RJMP STAGE2

STAGE3:				;Alert Stage (Countdown ended)
		;out 0 to 7segment
		SBI PORTD,PORTD0
		SBI PORTD,PORTD1
		SBI PORTD,PORTD4
		CBI PORTD,PORTD5
		LDI GX,SEG0
		OUT PORTB,GX

		;beep
		LDI XH,64
		LDI XL,255
		LDI ARG1,224
		RCALL BEEP
		
		RJMP RESET

POWERDOWN:
		RCALL SEG_ALLOFF
		;INT0 enable
		LDI GX,(1<<INT0)
		OUT GIMSK,GX

		;Powerdown Enable
		LDI GX,(1<<SM0)+(0<<SM1)+(1<<SE)
		OUT MCUCR,GX
		SLEEP	;Powerdown
POWERDOWN_RESUME:
		;Powerdown disable
		LDI GX,(0<<SM0)+(0<<SM1)+(0<<SE)
		OUT MCUCR,GX
		;INT0 disable
		LDI GX,(0<<INT0)
		OUT GIMSK,GX

		RET

KEYINPUT:
		;Read KEY twice
		IN GX,PIND	;1st

		;IF keys is not pushed then exit.
		ANDI GX,KEYMASK
		CPI GX,KEYMASK
		BREQ KEYINPUT_RET

		LDI ZH,KEYINWAIT_H
		LDI ZL,KEYINWAIT_L
		RCALL WAIT16
		IN GY,PIND	;2nd

		;Check 1st and 2nd both same data
		;(Chattering Filter)
		AND GX,GY
		ANDI GX,KEYMASK

		;CALL Event handler
		SBRS GX,PIND6
		RCALL TP_PUSHED		;T+
		SBRS GX,PIND3
		RCALL TM_PUSHED		;T-
		SBRS GX,PIND2
		RCALL START_PUSHED	;START
KEYINPUT_RET:
		RET
		
TP_PUSHED:
		INC MIN_L
		CPI MIN_L,0x0A
		BRNE TP_RET
		CPI MIN_H,0x09
		BREQ TP_99
		CLR MIN_L
		INC MIN_H
		RET
TP_99:
		LDI MIN_L,0x09
TP_RET:	RET

TM_PUSHED:
		DEC MIN_L
		CPI MIN_L,0xFF
		BRNE TM_RET
		CPI MIN_H,0x00
		BREQ TM_01
		LDI MIN_L,0x09
		DEC MIN_H
		RET
TM_01:
		LDI MIN_L,0x01
TM_RET:	RET

START_PUSHED:
		;Start 16bit Timer
		LDI GX,(1<<WGM12)+(1<<CS11)+(1<<CS10)
		OUT TCCR1B,GX	;CK select 1/64 - Comp Clear
		SBI DDRD,PORTD6
		SBI DDRD,PORTD3	;DDRB PD6,3(LED) output
		;INT0 enable
		LDI GX,(1<<INT0)
		OUT GIMSK,GX

START_RET:	RET

LED:
		CPI MSEC,0x01
		BREQ LEDA
		CPI MSEC,0x00
		BREQ LEDB

		RET
LEDA:
		CBI PORTD,PORTD6	;LED data change
		SBI PORTD,PORTD3
		RET
LEDB:
		SBI PORTD,PORTD6	;LED data change
		CBI PORTD,PORTD3
		RET

SEG_ALLOFF:
		SBI PORTD,PORTD0
		SBI PORTD,PORTD1
		SBI PORTD,PORTD4
		SBI PORTD,PORTD5

		;OUTPUT blank
		LDI GX,SEGBL
		OUT PORTB,GX
		RET

SEG:
		;SEGMENT1
		SBI PORTD,PORTD0
		SBI PORTD,PORTD1
		SBI PORTD,PORTD4
		CBI PORTD,PORTD5
		MOV ARG1,SEC_L
		RCALL PER_SEGMENT

		;SEGMENT2
		SBI PORTD,0
		SBI PORTD,1
		CBI PORTD,4
		SBI PORTD,5
		MOV ARG1,SEC_H
		RCALL PER_SEGMENT

		;SEGMENT3
		SBI PORTD,0
		CBI PORTD,1
		SBI PORTD,4
		SBI PORTD,5
		MOV ARG1,MIN_L
		RCALL PER_SEGMENT

		;SEGMENT4
		CBI PORTD,0
		SBI PORTD,1
		SBI PORTD,4
		SBI PORTD,5
		MOV ARG1,MIN_H
		RCALL PER_SEGMENT

		RET

PER_SEGMENT:
		;Output to Segment
		;ARG1 = data to segment

		;Convert BCD to Segment
		MOV GX,ARG1
		RCALL BCDTOSEG
		OUT PORTB,RETURN	;OUTPUT

		;WAIT(on)
		LDI ZH,SEGONH
		LDI ZL,SEGONL
		RCALL WAIT16

		;OUTPUT blank
		LDI GX,SEGBL
		OUT PORTB,GX

		;WAIT(off)
		LDI ARG1,SEGOFF
		RCALL WAIT

		RET

.include "general_routines.asm"

BCDTOSEG:
		;RETURN = BCDTOSEG(Arg1)
		;ARG1 = BCD
		;RETURN = 7segment data
		CPI ARG1,0x00
		BREQ SEGD0
		CPI ARG1,0x01
		BREQ SEGD1
		CPI ARG1,0x02
		BREQ SEGD2
		CPI ARG1,0x03
		BREQ SEGD3
		CPI ARG1,0x04
		BREQ SEGD4
		CPI ARG1,0x05
		BREQ SEGD5
		CPI ARG1,0x06
		BREQ SEGD6
		CPI ARG1,0x07
		BREQ SEGD7
		CPI ARG1,0x07
		BREQ SEGD7
		CPI ARG1,0x08
		BREQ SEGD8
		CPI ARG1,0x09
		BREQ SEGD9

		;if not match above, set blank.
		LDI RETURN,SEGBL
		RET
SEGD0:
		LDI RETURN,SEG0
		RET
SEGD1:
		LDI RETURN,SEG1
		RET
SEGD2:
		LDI RETURN,SEG2
		RET
SEGD3:
		LDI RETURN,SEG3
		RET
SEGD4:
		LDI RETURN,SEG4
		RET
SEGD5:
		LDI RETURN,SEG5
		RET
SEGD6:
		LDI RETURN,SEG6
		RET
SEGD7:
		LDI RETURN,SEG7
		RET
SEGD8:
		LDI RETURN,SEG8
		RET
SEGD9:
		LDI RETURN,SEG9
		RET

BEEP:
		;ARG1 = beep frequency
		;XH,XL = beep length
		;Port init
		SBI DDRD,DDD2	;PORTD2 set output (BUZZER)
BEEP_LOOP:
		CBI PORTD,PORTD2	;out L

		;WAIT
		PUSH ARG1
		RCALL WAIT
		POP ARG1

		SBI PORTD,PORTD2	;out H

		;WAIT
		PUSH ARG1
		RCALL WAIT
		POP ARG1

		SBIW XH:XL,1
		BRNE BEEP_LOOP	;if(X != 0) goto BEEP_LOOP

		CBI DDRD,DDD2	;PORTD2 set input (START BUTTON)
		RET

EXT_INT0:
		ADIW XH:XL,1
		CPI XH,0xFF
		BRNE EXT_INT0_RET
		CPI XL,0xFF
		BRNE EXT_INT0_RET

		;LDI,MSEC,0
		LDI SEC_L,1
		LDI SEC_H,0
		LDI MIN_L,0
		LDI MIN_H,0
EXT_INT0_RET:
		RETI
EXT_INT1:
		RETI
TIM_CAPT1:
TIM_COMP1:		;Interrupt per 500ms
		IN SREG_SAVER,SREG	;Save SREG

		;Decliments second/minute registers
		DEC MSEC
		CPI MSEC,0xFF
		BRNE TIM_CHK
		LDI MSEC,0x01
		DEC SEC_L
		CPI SEC_L,0xFF
		BRNE TIM_CHK
		LDI SEC_L,0x09
		DEC SEC_H
		CPI SEC_H,0xFF
		BRNE TIM_CHK
		LDI SEC_H,0x05
		DEC MIN_L
		CPI MIN_L,0xFF
		BRNE TIM_CHK
		LDI MIN_L,0x09
		DEC MIN_H

TIM_CHK:		;Check MIN_H/L SEC_H/L MSEC == 00000
		CPI SEC_L,0x00
		BRNE TIM_RET
		CPI SEC_H,0x00
		BRNE TIM_RET
		CPI MIN_L,0x00
		BRNE TIM_RET
		CPI MIN_H,0x00
		BRNE TIM_RET

		CLR GX
		OUT TCCR1B,GX	;Timer stop

		;INT0 disable
		LDI GX,(0<<INT0)
		OUT GIMSK,GX

TIM_RET:
		OUT SREG,SREG_SAVER	;Restore SREG
		RETI

TIM_OVF1:
TIM_OVF0:
UART_RXC:
UART_DRE:
UART_TXC:
ANA_COMP:
PCINT:
OC1B:
OC0A:
OC0B:
USI_START:
USI_OVF:
ERDY:
WDT:
		RETI
